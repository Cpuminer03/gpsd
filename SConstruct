### SCons build recipe for the GPSD project

EnsureSConsVersion(1,1,0)

import os, sys, shutil, re, commands
from glob import glob
from subprocess import Popen, PIPE, call
from os import access, F_OK
from leapsecond import save_leapseconds, make_leapsecond_include

#
# Build-control options
#

def internalize(s):
    return s.replace('-', '_')

boolopts = (
    ("ashtech",       "Ashtech support", True),
    ("earthmate",     "DeLorme EarthMate Zodiac support", True),
    ("evermore",      "EverMore binary support", True),
    ("fv18",          "San Jose Navigation FV-18 support", True),
    ("garmin",        "Garmin kernel driver support", True),
    ("garmintxt",     "Garmin Simple Text support", True),
    ("geostar",       "Geostar Protocol support", True),
    ("itrax",         "iTrax hardware support", True),
    ("mtk3301",       "MTK-3301 support", True),
    ("navcom",        "Navcom support", True),
    ("nmea",          "NMEA support", True),
    ("oncore",        "Motorola OnCore chipset support", True),
    ("sirf",          "SiRF chipset support", True),
    ("superstar2",    "Novatel SuperStarII chipset support", True),
    ("tnt",           "True North Technologies support", True),
    ("tripmate",      "DeLorme TripMate support", True),
    ("tsip",          "Trimble TSIP support", True),
    ("ubx",           "UBX Protocol support", True),
    # Non-GPS protcols
    ("aivdm",         "AIVDM support", True),
    ("gpsclock",      "GPSClock support", True),
    ("ntrip",         "NTRIP support", True),
    ("oceanserver",   "OceanServer support", True),
    ("rtcm104v2",     "rtcm104v2 support", True),
    ("rtcm104v3",     "rtcm104v3 support", False),
    # Time service
    ("ntpshm",        "NTP time hinting support", True),
    ("pps",           "PPS time syncing support", True),
    ("pps_on_cts",    "PPS pulse on CTS rather than DCD", False),
    # Export methods
    ("socket-export", "data export over sockets", True),
    ("dbus-export",   "enable DBUS export support", True),
    ("shm-export",    "export via shared memory", True),
    # Communication
    ("bluetooth",     "BlueZ support for Bluetooth devices", False),
    ("ipv6",          "build IPv6 support", True),
    # Client-side options
    ("clientdebug",   "client debugging support", True),
    ("oldstyle",      "oldstyle (pre-JSON) protocol support", True),
    ("libgpsmm",      "build C++ bindings", True),
    ("libQgpsmm",     "build QT bindings", False),
    ("reconfigure",   "allow gpsd to change device settings", True),
    ("controlsend",   "allow gpsctl/gpsmon to change device settings", True),
    ("cheapfloats",   "float ops are cheap, compute all error estimates", True),
    ("squelch",       "squelch gpsd_report/gpsd_hexdump to save cpu", False),
    # Miscellaneous
    ("profiling",     "Build with profiling enabled", True),
    ("timing",        "latency timing support", True),
    ("control-socket","control socket for hotplug notifications", True)
    )
for (name, help, default) in boolopts:
    internal_name = internalize(name)
    if default:
        AddOption('--disable-'+ name,
                  dest=internal_name,
                  default=True,
                  action="store_false",
                  help=help)
    else:
        AddOption('--enable-'+ name,
                  dest=internal_name,
                  default=False,
                  action="store_true",
                  help=help)

nonboolopts = (
    ("gpsd-user",           "USER",    "privilege revocation user",   ""),
    ("gpsd-group",          "GROUP",   "privilege revocation group",  ""),
    ("limited-max-clients", "CLIENTS", "maximum allowed clients",     0),
    ("limited-max-devices", "DEVICES", "maximum allowed devices",     0),
    ("fixed-port-speed",    "SPEED",   "fixed serial port speed",     0),
    )
for (name, metavar, help, default) in nonboolopts:
        internal_name = internalize(name)
        AddOption('--enable-'+ name,
                  dest=internal_name,
                  metavar=metavar,
                  default=default,
                  nargs=1, type='string',
                  help=help)

#
# Environment creation
#

env = Environment(tools=["default", "tar"])
env.SConsignFile(".sconsign.dblite")

# Should we build with profiling?
if GetOption('profiling'):
    env.Append(CCFLAGS=['-pg'])
    env.Append(LDFLAGS=['-pg'])

## Build help

if GetOption("help"):
    Return()

## Configuration

config = Configure(env)

confdefs = ["/* gpsd_config.h.  Generated by scons, do not hand-hack.  */\n\n"]

if not config.CheckCXX():
    print('!! Your compiler and/or environment is not correctly configured.')
    Exit(0)

if not config.CheckLib('libncurses'):
    ncurseslibs = []
else:
    ncurseslibs = ["ncurses"]

if not config.CheckLib('libusb'):
    confdefs.append("/* #undef HAVE_LIBUSB */\n\n")
    usblibs = []
else:
    confdefs.append("#define HAVE_LIBUSB 1\n\n")
    usblibs = ["usb"]
    
if not config.CheckLib('libpthread'):
    confdefs.append("/* #undef HAVE_LIBPTHREAD */\n\n")
    pthreadlibs = []
else:
    confdefs.append("#define HAVE_LIBPTHREAD 1\n\n")
    pthreadlibs = ["pthread"]
    
if not config.CheckLib('librt'):
    confdefs.append("/* #undef HAVE_LIBRT */\n\n")
    rtlibs = []
else:
    confdefs.append("#define HAVE_LIBRT 1\n\n")
    rtlibs = ["rt"]
    
if not config.CheckLib('libdbus'):
    confdefs.append("/* #undef HAVE_LIBDBUS */\n\n")
    dbuslibs = []
else:
    confdefs.append("#define HAVE_LIBDBUS 1\n\n")
    dbuslibs = ["dbus"]
    
if not config.CheckLib('libbluez'):
    confdefs.append("/* #undef HAVE_LIBBLUEZ */\n\n")
    bluezlibs = []
else:
    confdefs.append("#define HAVE_LIBBLUEZ 1\n\n")
    bluezlibs = ["bluez"]

keys = map(lambda x: x[0], boolopts) + map(lambda x: x[0], nonboolopts)
keys.sort()
for key in keys:
    key = internalize(key)
    value = GetOption(key)
    if type(value) == type(True):
        if value:
            confdefs.append("#define %s_ENABLE 1\n\n" % key.upper())
        else:
            confdefs.append("/* #undef %s_ENABLE */\n\n" % key.upper())
    elif value in (0, ""):
        confdefs.append("/* #undef %s */\n\n" % key.upper())
    else:
        if type(value) == type(-1):
            confdefs.append("#define %d %s\n\n" % value)
        elif type(value) == type(""):
            confdefs.append("#define %d \"%s\"\n\n" % value)
        else:
            raise ValueError

sys.stdout.writelines(confdefs)

if not os.path.exists('leapseconds.cache'):
    try:
        print "retrieving leapseconds.cache"
        save_leapseconds('leapseconds.cache')
    except:
        print "Failed to retrieve leapseconds"

env = config.Finish()

## Two shared libraries provide most of the code for the C programs

compiled_gpslib = env.Library(target="gps", source=[
	"ais_json.c",
	"daemon.c",
	"gpsutils.c",
	"geoid.c",
	"gpsdclient.c",
	"gps_maskdump.c",
	"hex.c",
	"json.c",
	"libgps_core.c",
	"libgps_json.c",
	"netlib.c",
	"rtcm2_json.c",
	"shared_json.c",
	"strl.c",
])

compiled_gpsdlib = env.Library(target="gpsd", source=[
	"bits.c",
	"bsd-base64.c",
	"crc24q.c",
	"gpsd_json.c",
	"isgps.c",
	"gpsd_maskdump.c",
	"timebase.c",
	"libgpsd_core.c",
	"net_dgpsip.c",
	"net_gnss_dispatch.c",
	"net_ntrip.c",
	"ntpshm.c",
	"packet.c",
	"pseudonmea.c",
	"serial.c",
	"srecord.c",
	"subframe.c",
	"drivers.c",
	"driver_aivdm.c",
	"driver_evermore.c",
	"driver_garmin.c",
	"driver_garmin_txt.c",
	"driver_geostar.c",
	"driver_italk.c",
	"driver_navcom.c",
	"driver_nmea.c",
	"driver_oncore.c",
	"driver_rtcm2.c",
	"driver_rtcm3.c",
	"driver_sirf.c",
	"driver_superstar2.c",
	"driver_tsip.c",
	"driver_ubx.c",
	"driver_zodiac.c",
])

env.Default(compiled_gpsdlib, compiled_gpslib)

# The libraries have dependencies on system libraries 

gpslibs = ["gps", "m"]
gpsdlibs = ["gpsd"] + usblibs + bluezlibs + gpslibs

## Programs to be built

gpsd = env.Program('gpsd', ['gpsd.c', 'gpsd_dbus.c'],
                   LIBS = gpsdlibs + pthreadlibs + rtlibs + dbuslibs)
gpsdecode = env.Program('gpsdecode', ['gpsdecode.c'], LIBS=gpsdlibs)
gpsctl = env.Program('gpsctl', ['gpsctl.c'], LIBS=gpsdlibs)
gpsmon = env.Program('gpsmon', ['gpsmon.c'], LIBS=gpsdlibs)
gpspipe = env.Program('gpspipe', ['gpspipe.c'], LIBS=gpslibs)
gpxlogger = env.Program('gpxlogger', ['gpxlogger.c'], LIBS=gpslibs+dbuslibs)
lcdgps = env.Program('lcdgps', ['lcdgps.c'], LIBS=gpslibs)
cgps = env.Program('cgps', ['cgps.c'], LIBS=gpslibs + ncurseslibs)

default_targets = [gpsd, gpsdecode, gpsctl, gpsmon, gpspipe, gpxlogger, lcdgps]
if ncurseslibs:
    default_targets.append(cgps)
env.Default(*default_targets)

# Test programs
testprogs = ["test_float", "test_trig", "test_bits", "test_packet",
             "test_mkgmtime", "test_geoid", "test_json"]
# TODO: conditionally add test_gpsmm and test_qgpsmm

# Python programs
python_progs = ["gpscat", "gpsfake", "gpsprof", "xgps", "xgpsspeed"]
python_modules = ["__init__.py", "misc.py", "fake.py", "gps.py", "client.py"]

test_float = env.Program('testapps/test_float', ['test_float.c'])
test_geoid = env.Program('testapps/test_geoid', ['test_geoid.c'], LIBS=gpslibs)
test_json = env.Program('testapps/test_json', ['test_json.c'], LIBS=gpslibs)
test_mkgmtime = env.Program('testapps/test_mkgmtime', ['test_mkgmtime.c'], LIBS=gpslibs)
test_trig = env.Program('testapps/test_trig', ['test_trig.c'], LIBS=["m"])
test_packet = env.Program('testapps/test_packet', ['test_packet.c'], LIBS=gpsdlibs)
test_bits = env.Program('testapps/test_bits', ['test_bits.c','bits.c'], LIBS=gpslibs)


# target = timebase.h
# source = leapsonds.cache
def build_timebase(target,source,env):
    timebase_contents = make_leapsecond_include(source[0])
    timebase_header = open(str(target[0]),"w")
    timebase_header.write(timebase_contents)
    timebase_header.close()

env.Command( 'timebase.h', 'leapseconds.cache', build_timebase )

env.Default('timebase.h')

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
