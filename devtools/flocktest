#!/usr/bin/env python
#
"""\
flocktest - shepherd script for the GPSD test flock

usage: flocktest [-c] [-q] [-d subdir] [-k key] -v [-x exclude] [-?]

The -? makes flocktest prints this help and exits.

The -c option dumps flocktest's configuration and exits

The -k mode installs a specified ssh public key an all machines

Otherwise, the remote flockdriver script is executed on each machine.

The -d option passes it a name for the remote test subdirectory

The -q option supprssed CIA notifications

The -v option shows all ssh commands issued and runs flockdriver with -x set.

The -x option specifies a comma-separated list of items that are
either remote hostnames or architecture tags.  Matching sites are
excluded.  You may wish to use this to avoid doing remote tests that
are redundant with your local ones.

If you do not specify a subdirectory name, the value of $LOGNAME will be used.
"""

import os, sys, ConfigParser, getopt, socket, threading, commands, time

flockdriver = '''
#!/bin/sh
#
# flockdriver - conduct regression tests as an agent for a remote flocktest
#
# This file is generated.  Do not hand-hack.

generator="http://gpsd.berlios.de/flockdriver"

quiet=no
while getopts dq opt
do
    case $opt in
        d) subdir=$2; shift; shift ;;
        q) quiet=yes; shift ;;
    esac
done

site=`hostname --fqdn`

if [ -f "flockdriver.lock" ]
then
    logmessage="A test was already running when you initiated this one."
    cd $subdir
else
    echo "Test begins: "`date`

    echo "Site: $site" 
    echo "Directory: ${PWD}/${subdir}"

    # Set up or update the repo
    if [ ! -d $subdir ]
    then
	git clone %(origin)s $subdir
	cd $subdir
    else
	cd $subdir;
	git pull
    fi

    # Perform the test
    if ( %(regression)s )
    then
	logmessage="Regression test succeeded."
	status=0
    else
	logmessage="Regression test failed."
	status=1
    fi

    echo "Test ends: "`date`
fi

# Here is where we abuse CIA to do our notfications for us.

# Addresses for the e-mail
from="FLOCKDRIVER-NOREPLY@${site}"
to="cia@cia.navi.cx"

# SMTP client to use
sendmail="sendmail -t -f ${from}"

# Should include all places sendmail is likely to lurk. 
PATH="$PATH:/usr/sbin/"

# Identify what just succeeded or failed
merged=$(git rev-parse HEAD)
rev=$(git describe ${merged} 2>/dev/null)
[ -z ${rev} ] && rev=${merged}
refname=$(git symbolic-ref HEAD 2>/dev/null)
refname=${refname##refs/heads/}

# And the git version
gitver=$(git --version)
gitver=${gitver##* }

if [ $quiet = no ]
then
    ${sendmail} << EOM
Message-ID: <${merged}.${subdir}.blip@%(project)s>
From: ${from}
To: ${to}
Content-type: text/xml
Subject: DeliverXML

<message>
  <generator>
    <name>%(project)s Remote Test Flock Driver</name>
    <version>${gitver}</version>
    <url>${generator}</url>
  </generator>
  <source>
    <project>%(project)s</project>
    <branch>${refname}@${site}</branch>
  </source>
  <timestamp>`date`</timestamp>
  <body>
    <commit>
      <author>${subdir}</author>
      <revision>${rev}</revision>
      <log>${logmessage}</log>
    </commit>
  </body>
</message>
EOM
fi

exit $status
# End.
'''

class FlockThread(threading.Thread):
    def __init__(self, site, command):
        threading.Thread.__init__(self)
        self.site = site
        self.command = command
    def run(self):
        (self.status, self.output) = commands.getstatusoutput(self.command)

class TestSite:
    "Methods for performing tests on a single remote site."
    def __init__(self, fqdn, config, execute=True):
        self.fqdn = fqdn
        self.config = config
        self.execute = execute
        self.me = self.config["login"] + "@" + self.fqdn
    def error(self, msg):
        "Report an error while executing a remote command."
        sys.stderr.write("%s: %s\n" % (self.fqdn, msg))
    def do_remote(self, remote):
        "Execute a command on a specified remote host."
        command = "ssh "
        if "port" in self.config:
            command += "-p %s " % self.config["port"]
        command += "%s '%s'" %  (self.me, remote)
        if self.verbose:
            print command
        self.thread =  FlockThread(self, command)
        self.thread.start()
    def update_remote(self, filename):
        "Copy a specified file to the remote home."
        command = "scp %s %s:~" % (filename, self.me)
        if self.verbose:
            print command
        status = os.system(command)
        if status:
            self.error("copy with '%s' failed" % command)
        return status
    def do_append(self, filename, string):
        "Append a line to a specified remote file, in foreground."
        self.do_remote("echo \"%s\" >>%s" % (string.strip(), filename))
    def do_flockdriver(self, agent, invocation):
        "Copy flockdriver to the remote site and run it."
        self.starttime = time.time()
        uploader = "ssh -p %s %s 'cat >%s'" \
                       % (self.config.get("port", "22"), self.me, agent)
        if self.verbose:
            print uploader
        ofp = os.popen(uploader, "w")
        ofp.write(flockdriver % self.config)
        if ofp.close():
            print >>sys.stderr, "flocktest: agen upload failed"
        else:
            self.do_remote(invocation)
        self.elapsed = time.time() - self.starttime

class TestFlock:
    "Methods for performing parallel tests on a flock of remote sites."
    ssh_options = "no-port-forwarding,no-X11-forwarding," \
                 "no-agent-forwarding,no-pty "
    def __init__(self, sitelist):
        self.sitelist = sitelist
    def update_remote(self, filename):
        "Copy a specified file to the remote home on all machines."
        for site in self.sitelist:
            site.update_remote(filename)
    def do_remotes(self, agent, invocation):
        "Execute a command on all machines in the flock."
        slaves = []
        print "== testing at: %s ==" % flock.listdump()
        starttime = time.time()
        for site in self.sitelist:
            site.do_flockdriver(agent, invocation)
        for site in sites:
            site.thread.join()
        failed = 0
        for site in sites:
            if site.thread.status:
                print "== %s test FAILED in %.2f seconds, status %d ==" % (site.fqdn, site.elapsed, site.thread.status)
                failed += 1
                print site.thread.output
            else:
                print "== %s test succeeded in %.2f seconds ==" % (site.fqdn, site.elapsed)
        elapsed = time.time() - starttime
        print "== %d tests completed in %.2f seconds: %d failed ==" % (len(sites), elapsed, failed)
    def exclude(self, exclusions):
        "Delete matching sites."
        self.sitelist = filter(lambda x: x.fqdn not in exclusions and x.config["arch"] not in exclusions, self.sitelist)
    def add_key(self, key):
        "Add the specified public key to all sites."
        for site in self.sitelist:
            site.do_append(".ssh/authorized_keys",
                           TestFlock.ssh_options + " " + key)
    def listdump(self):
        "Return a dump of the site list."
        return ", ".join(map(lambda x: x.fqdn, self.sitelist))

if __name__ == '__main__':
    try:
        (options, arguments) = getopt.getopt(sys.argv[1:], "cdk:qvx:?")
    except getopt.GetoptError, msg:
        print "flocktest: " + str(msg)
        raise SystemExit, 1

    exclusions = []
    subdir = None
    key = None
    verbose = False
    dumpconf = False
    cianotify = True
    for (switch, val) in options:
        if  switch == '-c':
            dumpconf = True
        elif  switch == '-d':
            subdir = val
        elif  switch == '-k':
            key = val
        elif switch == '-q':
            cianotify = False
        elif switch == '-v':
            verbose = True
        elif switch == '-x':
            exclusions = map(lambda x: x.strip(), val.split(","))
        else: # switch == '-?':
            print __doc__
            sys.exit(0)

    config = ConfigParser.RawConfigParser()
    config.read(["flocktest.ini", ".flocktest.ini"])
    sites = []
    for site in config.sections():
        newsite = TestSite(site, dict(config.items(site)))
        newsite.verbose = verbose
        if newsite.config["status"].lower() == "up":
            sites.append(newsite)
    flock = TestFlock(sites)
    if exclusions:
        flock.exclude(exclusions)

    if dumpconf:
        config.write(sys.stdout)
    elif key:
        flock.add_key(val)
    else:
        if not subdir:
            subdir = os.getenv("LOGNAME")
        if not subdir:
            print "flocktest: you don't exist, go away!"
            sys.exit(1)
        agent = "flockdriver.%s" % subdir
        invocation = "sh flockdriver.%s -d %s" % (subdir, subdir,)
        if not cianotify:
            invocation += " -q"
        if verbose > 1:
            invocation = "sh -x " + invocation
        flock.do_remotes(agent, invocation)

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
